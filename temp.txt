# scripts/rl_inference_server.pyì˜ ê¸°ì¡´ ì½”ë“œì— ë‹¤ìŒ ë¶€ë¶„ë“¤ì„ ì¶”ê°€

import torch.nn.functional as F
from typing import Dict, List, Any, Tuple
import numpy as np

# ìƒˆë¡œìš´ ìš”ì²­/ì‘ë‹µ ëª¨ë¸ ì¶”ê°€
class XAIRequest(BaseModel):
    investment_amount: float
    risk_tolerance: str = "moderate"
    investment_horizon: int = 252

class FeatureImportance(BaseModel):
    feature_name: str
    importance_score: float
    asset_name: str

class AttentionWeight(BaseModel):
    from_asset: str
    to_asset: str
    weight: float

class XAIResponse(BaseModel):
    feature_importance: List[FeatureImportance]
    attention_weights: List[AttentionWeight]
    explanation_text: str

def calculate_feature_importance(model, input_data: torch.Tensor) -> List[Dict]:
    """Feature importance ê³„ì‚° (Integrated Gradients ê¸°ë°˜)"""
    model.eval()
    input_data = input_data.requires_grad_(True)
    
    # ê¸°ì¤€ì„  (ëª¨ë“  ê°’ì´ 0ì¸ ìƒíƒœ)
    baseline = torch.zeros_like(input_data)
    
    # Integrated Gradients ê³„ì‚°
    steps = 50
    importance_scores = []
    
    for i in range(steps + 1):
        # ì„ í˜• ë³´ê°„
        alpha = i / steps
        interpolated = baseline + alpha * (input_data - baseline)
        interpolated.requires_grad_(True)
        
        # ìˆœì „íŒŒ ë° ì—­ì „íŒŒ
        output, _ = model(interpolated)
        
        # ê° ì¶œë ¥ì— ëŒ€í•œ ê·¸ë˜ë””ì–¸íŠ¸ ê³„ì‚°
        gradients = []
        for j in range(output.size(1)):  # ê° ìì‚°ë³„ë¡œ
            if interpolated.grad is not None:
                interpolated.grad.zero_()
            
            output[0, j].backward(retain_graph=True)
            grad = interpolated.grad.clone()
            gradients.append(grad)
    
    # í‰ê·  ê·¸ë˜ë””ì–¸íŠ¸ ê³„ì‚°
    avg_gradients = torch.stack(gradients).mean(dim=0)
    
    # ì¤‘ìš”ë„ ì ìˆ˜ ê³„ì‚° (ê·¸ë˜ë””ì–¸íŠ¸ * ì…ë ¥ê°’)
    importance = avg_gradients * (input_data - baseline)
    importance = importance.abs().mean(dim=0)  # ì ˆëŒ“ê°’ì˜ í‰ê· 
    
    # ê²°ê³¼ í¬ë§·íŒ…
    feature_importance = []
    for asset_idx in range(len(STOCK_SYMBOLS)):
        for feature_idx, feature_name in enumerate(FEATURE_NAMES):
            if asset_idx < importance.size(0) and feature_idx < importance.size(1):
                score = float(importance[asset_idx, feature_idx])
                feature_importance.append({
                    "feature_name": feature_name,
                    "asset_name": STOCK_SYMBOLS[asset_idx],
                    "importance_score": score
                })
    
    # ì¤‘ìš”ë„ ìˆœìœ¼ë¡œ ì •ë ¬
    feature_importance.sort(key=lambda x: x["importance_score"], reverse=True)
    return feature_importance[:20]  # ìƒìœ„ 20ê°œë§Œ ë°˜í™˜

def extract_attention_weights(model, input_data: torch.Tensor) -> List[Dict]:
    """Self-Attention weights ì¶”ì¶œ"""
    model.eval()
    
    with torch.no_grad():
        # ëª¨ë¸ì˜ ì–´í…ì…˜ ë ˆì´ì–´ì—ì„œ ê°€ì¤‘ì¹˜ ì¶”ì¶œ
        # LSTM ì²˜ë¦¬
        lstm_outputs = []
        batch_size = input_data.size(0)
        
        for i in range(input_data.size(1)):
            asset_feats = input_data[:, i, :].view(batch_size, 1, -1)
            lstm_out, _ = model.lstm(asset_feats)
            asset_out = lstm_out[:, -1, :]
            lstm_outputs.append(asset_out)
        
        lstm_stacked = torch.stack(lstm_outputs, dim=1)
        
        # ì–´í…ì…˜ ê°€ì¤‘ì¹˜ ê³„ì‚°
        context, attention_weights = model.attention(lstm_stacked)
        
        # ì–´í…ì…˜ ê°€ì¤‘ì¹˜ë¥¼ ë¦¬ìŠ¤íŠ¸ë¡œ ë³€í™˜
        attention_list = []
        weights = attention_weights.squeeze(0).cpu().numpy()
        
        for i, from_asset in enumerate(STOCK_SYMBOLS):
            for j, to_asset in enumerate(STOCK_SYMBOLS):
                if i < weights.shape[0] and j < weights.shape[1]:
                    weight = float(weights[i, j])
                    if weight > 0.01:  # ì„ê³„ê°’ ì´ìƒë§Œ í¬í•¨
                        attention_list.append({
                            "from_asset": from_asset,
                            "to_asset": to_asset,
                            "weight": weight
                        })
        
        return attention_list

def generate_explanation_text(
    feature_importance: List[Dict], 
    attention_weights: List[Dict],
    allocation: List[Dict]
) -> str:
    """XAI ê²°ê³¼ë¥¼ ë°”íƒ•ìœ¼ë¡œ ì„¤ëª… í…ìŠ¤íŠ¸ ìƒì„±"""
    
    # ê°€ì¥ ì¤‘ìš”í•œ íŠ¹ì„±ë“¤
    top_features = feature_importance[:5]
    
    # ê°€ì¥ ë†’ì€ ë°°ë¶„ì„ ë°›ì€ ìì‚°ë“¤
    top_assets = sorted(
        [a for a in allocation if a["symbol"] != "í˜„ê¸ˆ"], 
        key=lambda x: x["weight"], 
        reverse=True
    )[:3]
    
    explanation = "AI í¬íŠ¸í´ë¦¬ì˜¤ ê²°ì • ê·¼ê±°:\n\n"
    
    # ì£¼ìš” ì˜í–¥ ìš”ì¸
    explanation += "ğŸ” ì£¼ìš” ì˜í–¥ ìš”ì¸:\n"
    for i, feature in enumerate(top_features, 1):
        explanation += f"{i}. {feature['asset_name']}ì˜ {feature['feature_name']}: {feature['importance_score']:.3f}\n"
    
    explanation += "\nğŸ“Š í•µì‹¬ íˆ¬ì ë…¼ë¦¬:\n"
    
    # ìƒìœ„ ìì‚°ë³„ ì„¤ëª…
    for asset in top_assets:
        symbol = asset["symbol"]
        weight = asset["weight"] * 100
        
        # í•´ë‹¹ ìì‚°ì˜ ì£¼ìš” íŠ¹ì„± ì°¾ê¸°
        asset_features = [f for f in top_features if f["asset_name"] == symbol]
        
        if asset_features:
            main_feature = asset_features[0]["feature_name"]
            explanation += f"â€¢ {symbol} ({weight:.1f}%): {main_feature} ì§€í‘œê°€ ê¸ì •ì  ì‹ í˜¸ë¥¼ ë³´ì„\n"
        else:
            explanation += f"â€¢ {symbol} ({weight:.1f}%): ì•ˆì •ì ì¸ ì„±ê³¼ ê¸°ëŒ€\n"
    
    # ë¦¬ìŠ¤í¬ ê´€ë¦¬
    cash_allocation = next((a for a in allocation if a["symbol"] == "í˜„ê¸ˆ"), None)
    if cash_allocation and cash_allocation["weight"] > 0.1:
        explanation += f"\nğŸ›¡ï¸ ë¦¬ìŠ¤í¬ ê´€ë¦¬:\n"
        explanation += f"â€¢ í˜„ê¸ˆ {cash_allocation['weight']*100:.1f}% ë³´ìœ ë¡œ ë³€ë™ì„± ì™„ì¶©\n"
    
    return explanation

@app.post("/explain", response_model=XAIResponse)
async def explain_prediction(request: XAIRequest):
    """XAI ì„¤ëª… ì—”ë“œí¬ì¸íŠ¸"""
    
    if model is None:
        raise HTTPException(status_code=503, detail="ëª¨ë¸ì´ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")
    
    try:
        # ì˜ˆì¸¡ê³¼ ë™ì¼í•œ ë°ì´í„° ì¤€ë¹„
        market_data = get_market_data_with_context(
            request.investment_amount, 
            request.risk_tolerance
        )
        
        if market_data is None:
            raise HTTPException(status_code=500, detail="ì‹œì¥ ë°ì´í„°ë¥¼ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
        
        enhanced_data = enhance_data_with_user_context(
            market_data, 
            request.investment_amount, 
            request.risk_tolerance, 
            request.investment_horizon
        )
        
        input_tensor = torch.FloatTensor(enhanced_data).unsqueeze(0).to(DEVICE)
        
        # XAI ê³„ì‚°
        feature_importance = calculate_feature_importance(model, input_tensor)
        attention_weights = extract_attention_weights(model, input_tensor)
        
        # í˜„ì¬ ì˜ˆì¸¡ ê²°ê³¼ë„ í•¨ê»˜ ê³„ì‚°
        prediction_result = predict_portfolio(
            request.investment_amount,
            request.risk_tolerance, 
            request.investment_horizon
        )
        
        explanation_text = generate_explanation_text(
            feature_importance, 
            attention_weights,
            prediction_result["allocation"]
        )
        
        return XAIResponse(
            feature_importance=[
                FeatureImportance(
                    feature_name=item["feature_name"],
                    importance_score=item["importance_score"],
                    asset_name=item["asset_name"]
                ) for item in feature_importance
            ],
            attention_weights=[
                AttentionWeight(
                    from_asset=item["from_asset"],
                    to_asset=item["to_asset"],
                    weight=item["weight"]
                ) for item in attention_weights
            ],
            explanation_text=explanation_text
        )
        
    except Exception as e:
        print(f"XAI ì„¤ëª… ìƒì„± ì˜¤ë¥˜: {e}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail="XAI ì„¤ëª… ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.")

// lib/types.tsì˜ ê¸°ì¡´ íƒ€ì…ë“¤ì— ì¶”ê°€

// XAI ê´€ë ¨ íƒ€ì… ì •ì˜
export interface FeatureImportance {
	feature_name: string;
	importance_score: number;
	asset_name: string;
}

export interface AttentionWeight {
	from_asset: string;
	to_asset: string;
	weight: number;
}

export interface XAIData {
	feature_importance: FeatureImportance[];
	attention_weights: AttentionWeight[];
	explanation_text: string;
}

// XAI API ìš”ì²­ íƒ€ì…
export interface XAIRequest {
	investment_amount: number;
	risk_tolerance: string;
	investment_horizon: number;
}

import { NextRequest, NextResponse } from "next/server";
import { XAIData } from "@/lib/types";

export async function POST(request: NextRequest) {
	try {
		const { investmentAmount, riskTolerance, investmentHorizon } = await request.json();

		if (!investmentAmount || investmentAmount <= 0) {
			return NextResponse.json({ error: "ìœ íš¨í•œ íˆ¬ì ê¸ˆì•¡ì„ ì…ë ¥í•´ì£¼ì„¸ìš”." }, { status: 400 });
		}

		console.log("XAI ì„¤ëª… ìš”ì²­:", { investmentAmount, riskTolerance, investmentHorizon });

		// ë°±ì—”ë“œ XAI ì„œë²„ í˜¸ì¶œ
		const response = await fetch("http://localhost:8000/explain", {
			method: "POST",
			headers: {
				"Content-Type": "application/json",
			},
			body: JSON.stringify({
				investment_amount: investmentAmount,
				risk_tolerance: riskTolerance,
				investment_horizon: investmentHorizon,
			}),
		});

		if (!response.ok) {
			throw new Error(`XAI ì„œë²„ ì˜¤ë¥˜: ${response.status}`);
		}

		const data = await response.json();
		console.log("XAI ì„œë²„ ì‘ë‹µ:", data);

		// ì‘ë‹µ ë°ì´í„° êµ¬ì¡° ë³€í™˜
		const xaiData: XAIData = {
			feature_importance: data.feature_importance,
			attention_weights: data.attention_weights,
			explanation_text: data.explanation_text,
		};

		return NextResponse.json(xaiData);
	} catch (error) {
		console.error("XAI ì„¤ëª… ìƒì„± ì˜¤ë¥˜:", error);

		// í´ë°±: ë”ë¯¸ ë°ì´í„° ë°˜í™˜ (ê°œë°œ/í…ŒìŠ¤íŠ¸ìš©)
		const fallbackData: XAIData = {
			feature_importance: [
				{ feature_name: "Close", importance_score: 0.245, asset_name: "AAPL" },
				{ feature_name: "RSI", importance_score: 0.198, asset_name: "MSFT" },
				{ feature_name: "MACD", importance_score: 0.176, asset_name: "GOOGL" },
				{ feature_name: "Volume", importance_score: 0.134, asset_name: "AMZN" },
				{ feature_name: "MA21", importance_score: 0.112, asset_name: "TSLA" },
			],
			attention_weights: [
				{ from_asset: "AAPL", to_asset: "MSFT", weight: 0.23 },
				{ from_asset: "MSFT", to_asset: "GOOGL", weight: 0.19 },
				{ from_asset: "GOOGL", to_asset: "AMZN", weight: 0.16 },
				{ from_asset: "TSLA", to_asset: "AAPL", weight: 0.14 },
				{ from_asset: "AMZN", to_asset: "TSLA", weight: 0.12 },
			],
			explanation_text: `AI í¬íŠ¸í´ë¦¬ì˜¤ ê²°ì • ê·¼ê±°:

ğŸ” ì£¼ìš” ì˜í–¥ ìš”ì¸:
1. AAPLì˜ Close: 0.245
2. MSFTì˜ RSI: 0.198
3. GOOGLì˜ MACD: 0.176
4. AMZNì˜ Volume: 0.134
5. TSLAì˜ MA21: 0.112

ğŸ“Š í•µì‹¬ íˆ¬ì ë…¼ë¦¬:
â€¢ AAPL (18.0%): Close ì§€í‘œê°€ ê¸ì •ì  ì‹ í˜¸ë¥¼ ë³´ì„
â€¢ MSFT (16.0%): RSI ì§€í‘œê°€ ê¸ì •ì  ì‹ í˜¸ë¥¼ ë³´ì„
â€¢ GOOGL (12.0%): MACD ì§€í‘œê°€ ê¸ì •ì  ì‹ í˜¸ë¥¼ ë³´ì„

ğŸ›¡ï¸ ë¦¬ìŠ¤í¬ ê´€ë¦¬:
â€¢ í˜„ê¸ˆ 14.0% ë³´ìœ ë¡œ ë³€ë™ì„± ì™„ì¶©`,
		};

		return NextResponse.json(fallbackData);
	}
}

import { BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer, Cell } from "recharts";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { XAIData } from "@/lib/types";
import { Brain, TrendingUp, Eye, Info } from "lucide-react";

interface XAIVisualizationProps {
	xaiData: XAIData | null;
	isLoading: boolean;
}

const FEATURE_COLORS: { [key: string]: string } = {
	Open: "#3B82F6",
	High: "#10B981", 
	Low: "#F59E0B",
	Close: "#EF4444",
	Volume: "#8B5CF6",
	MACD: "#06B6D4",
	RSI: "#84CC16",
	MA14: "#F97316",
	MA21: "#EC4899",
	MA100: "#6B7280"
};

const ASSET_COLORS: { [key: string]: string } = {
	AAPL: "#007AFF",
	MSFT: "#00A4EF", 
	AMZN: "#FF9900",
	GOOGL: "#4285F4",
	AMD: "#ED1C24",
	TSLA: "#CC0000",
	JPM: "#0066CC",
	JNJ: "#D50000",
	PG: "#005CA9",
	V: "#1434CB"
};

export default function XAIVisualization({ xaiData, isLoading }: XAIVisualizationProps) {
	if (isLoading) {
		return (
			<div className="bg-white rounded-xl p-8 shadow-lg border border-gray-100">
				<div className="text-center">
					<div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto mb-4"></div>
					<p className="text-gray-600">AI ì˜ì‚¬ê²°ì • ê³¼ì •ì„ ë¶„ì„í•˜ê³  ìˆìŠµë‹ˆë‹¤...</p>
				</div>
			</div>
		);
	}

	if (!xaiData) {
		return null;
	}

	// Feature Importance ì°¨íŠ¸ìš© ë°ì´í„° ë³€í™˜
	const featureData = xaiData.feature_importance.map((item, index) => ({
		name: `${item.asset_name}-${item.feature_name}`,
		importance: item.importance_score,
		asset: item.asset_name,
		feature: item.feature_name,
		color: FEATURE_COLORS[item.feature_name] || "#6B7280"
	}));

	// Attention Weights ë„¤íŠ¸ì›Œí¬ ì‹œê°í™”ìš© ë°ì´í„°
	const topAttentionWeights = xaiData.attention_weights
		.sort((a, b) => b.weight - a.weight)
		.slice(0, 10); // ìƒìœ„ 10ê°œë§Œ

	return (
		<section className="py-12 bg-gradient-to-br from-purple-50 to-blue-50">
			<div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
				<div className="text-center mb-8">
					<h2 className="text-3xl font-bold text-gray-900 mb-4 flex items-center justify-center">
						<Brain className="w-8 h-8 mr-3 text-purple-600" />
						AI ì˜ì‚¬ê²°ì • ë¶„ì„
					</h2>
					<p className="text-lg text-gray-600">
						ê°•í™”í•™ìŠµ ëª¨ë¸ì´ ì–´ë–¤ ìš”ì†Œë¥¼ ê³ ë ¤í•´ í¬íŠ¸í´ë¦¬ì˜¤ë¥¼ êµ¬ì„±í–ˆëŠ”ì§€ ë¶„ì„ ê²°ê³¼ì…ë‹ˆë‹¤
					</p>
				</div>

				<div className="grid grid-cols-1 xl:grid-cols-2 gap-8 mb-8">
					{/* Feature Importance Chart */}
					<Card className="bg-white shadow-lg border border-gray-100">
						<CardHeader>
							<CardTitle className="text-xl flex items-center">
								<TrendingUp className="w-5 h-5 mr-2 text-blue-600" />
								ì˜í–¥ë„ ë¶„ì„
							</CardTitle>
							<CardDescription>
								ê° ê¸°ìˆ ì  ì§€í‘œê°€ í¬íŠ¸í´ë¦¬ì˜¤ ê²°ì •ì— ë¯¸ì¹œ ì˜í–¥ë ¥ì„ ë³´ì—¬ì¤ë‹ˆë‹¤
							</CardDescription>
						</CardHeader>
						<CardContent>
							<div className="h-80">
								<ResponsiveContainer width="100%" height="100%">
									<BarChart 
										data={featureData}
										margin={{ top: 20, right: 30, left: 20, bottom: 80 }}
									>
										<CartesianGrid strokeDasharray="3 3" stroke="#f3f4f6" />
										<XAxis 
											dataKey="name" 
											tick={{ fontSize: 10 }}
											angle={-45}
											textAnchor="end"
											height={80}
										/>
										<YAxis 
											tick={{ fontSize: 12 }}
											label={{ value: 'ì¤‘ìš”ë„ ì ìˆ˜', angle: -90, position: 'insideLeft' }}
										/>
										<Tooltip
											formatter={(value: any, name: any, props: any) => [
												`${(value * 100).toFixed(1)}%`,
												`${props.payload.asset} - ${props.payload.feature}`
											]}
											contentStyle={{
												backgroundColor: "#fff",
												border: "1px solid #e5e7eb",
												borderRadius: "8px",
												boxShadow: "0 4px 6px -1px rgba(0, 0, 0, 0.1)",
											}}
										/>
										<Bar dataKey="importance" radius={[4, 4, 0, 0]}>
											{featureData.map((entry, index) => (
												<Cell key={`cell-${index}`} fill={entry.color} />
											))}
										</Bar>
									</BarChart>
								</ResponsiveContainer>
							</div>
							
							{/* ë²”ë¡€ */}
							<div className="mt-4 flex flex-wrap gap-2">
								{Object.entries(FEATURE_COLORS).map(([feature, color]) => (
									<Badge key={feature} variant="outline" className="text-xs">
										<div 
											className="w-3 h-3 rounded-full mr-1" 
											style={{ backgroundColor: color }}
										/>
										{feature}
									</Badge>
								))}
							</div>
						</CardContent>
					</Card>

					{/* Attention Weights Visualization */}
					<Card className="bg-white shadow-lg border border-gray-100">
						<CardHeader>
							<CardTitle className="text-xl flex items-center">
								<Eye className="w-5 h-5 mr-2 text-green-600" />
								ì£¼ëª©ë„ ë„¤íŠ¸ì›Œí¬
							</CardTitle>
							<CardDescription>
								AIê°€ ì–´ë–¤ ìì‚°ë“¤ ê°„ì˜ ê´€ê³„ì— ì£¼ëª©í–ˆëŠ”ì§€ ë³´ì—¬ì¤ë‹ˆë‹¤
							</CardDescription>
						</CardHeader>
						<CardContent>
							<div className="space-y-4">
								{topAttentionWeights.map((weight, index) => (
									<div 
										key={index}
										className="flex items-center justify-between p-4 bg-gradient-to-r from-gray-50 to-gray-100 rounded-lg hover:shadow-md transition-shadow"
									>
										<div className="flex items-center space-x-4">
											<div className="flex items-center space-x-2">
												<div 
													className="w-4 h-4 rounded-full shadow-sm"
													style={{ backgroundColor: ASSET_COLORS[weight.from_asset] || "#6B7280" }}
												/>
												<span className="font-semibold text-gray-800">
													{weight.from_asset}
												</span>
											</div>
											
											<div className="text-gray-400">â†’</div>
											
											<div className="flex items-center space-x-2">
												<div 
													className="w-4 h-4 rounded-full shadow-sm"
													style={{ backgroundColor: ASSET_COLORS[weight.to_asset] || "#6B7280" }}
												/>
												<span className="font-semibold text-gray-800">
													{weight.to_asset}
												</span>
											</div>
										</div>
										
										<div className="flex items-center space-x-3">
											<div className="w-20 bg-gray-200 rounded-full h-2">
												<div 
													className="bg-blue-600 h-2 rounded-full transition-all duration-300"
													style={{ width: `${weight.weight * 100}%` }}
												/>
											</div>
											<span className="text-sm font-bold text-blue-600 w-12 text-right">
												{(weight.weight * 100).toFixed(1)}%
											</span>
										</div>
									</div>
								))}
							</div>
						</CardContent>
					</Card>
				</div>

				{/* AI ì„¤ëª… í…ìŠ¤íŠ¸ */}
				<Card className="bg-white shadow-lg border border-gray-100">
					<CardHeader>
						<CardTitle className="text-xl flex items-center">
							<Info className="w-5 h-5 mr-2 text-orange-600" />
							AI ì„¤ëª…
						</CardTitle>
						<CardDescription>
							í¬íŠ¸í´ë¦¬ì˜¤ êµ¬ì„±ì— ëŒ€í•œ AIì˜ ìƒì„¸í•œ ì„¤ëª…ì…ë‹ˆë‹¤
						</CardDescription>
					</CardHeader>
					<CardContent>
						<div className="bg-gradient-to-r from-blue-50 to-purple-50 rounded-lg p-6">
							<pre className="text-gray-800 whitespace-pre-wrap font-medium leading-relaxed">
								{xaiData.explanation_text}
							</pre>
						</div>
						
						<div className="mt-6 p-4 bg-yellow-50 border-l-4 border-yellow-400 rounded-r-lg">
							<p className="text-sm text-yellow-800">
								<strong>ì°¸ê³ :</strong> ì´ ì„¤ëª…ì€ AI ëª¨ë¸ì˜ ë‚´ë¶€ ê³„ì‚°ì„ ë°”íƒ•ìœ¼ë¡œ ìƒì„±ë˜ì—ˆìœ¼ë©°, 
								ì‹¤ì œ ì‹œì¥ ìƒí™©ê³¼ ë‹¤ë¥¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤. íˆ¬ì ê²°ì •ì‹œ ì°¸ê³  ìë£Œë¡œë§Œ í™œìš©í•´ì£¼ì„¸ìš”.
							</p>
						</div>
					</CardContent>
				</Card>
			</div>
		</section>
	);
}

// app/page.tsxì— ì¶”ê°€í•  ë¶€ë¶„ë“¤

// ê¸°ì¡´ importì— ì¶”ê°€
import { XAIData } from "@/lib/types";
import XAIVisualization from "@/components/XAIVisualization";
import { Brain } from "lucide-react";

// ê¸°ì¡´ ìƒíƒœ ë³€ìˆ˜ë“¤ì— ì¶”ê°€
const [xaiData, setXaiData] = useState<XAIData | null>(null);
const [isLoadingXAI, setIsLoadingXAI] = useState(false);
const [showXAI, setShowXAI] = useState(false);

// XAI ì„¤ëª… ê°€ì ¸ì˜¤ê¸° í•¨ìˆ˜ ì¶”ê°€
const handleXAIAnalysis = async () => {
	if (!investmentAmount) {
		setError("ë¨¼ì € í¬íŠ¸í´ë¦¬ì˜¤ ë¶„ì„ì„ ì™„ë£Œí•´ì£¼ì„¸ìš”.");
		return;
	}

	setIsLoadingXAI(true);
	setError("");

	try {
		console.log("XAI ë¶„ì„ ìš”ì²­:", {
			investmentAmount,
			riskTolerance,
			investmentHorizon: investmentHorizon[0],
		});

		const response = await fetch("/api/explain", {
			method: "POST",
			headers: {
				"Content-Type": "application/json",
			},
			body: JSON.stringify({
				investmentAmount: Number.parseInt(investmentAmount),
				riskTolerance,
				investmentHorizon: investmentHorizon[0],
			}),
		});

		if (!response.ok) {
			throw new Error("XAI ë¶„ì„ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
		}

		const data = await response.json();
		console.log("XAI ë¶„ì„ ê²°ê³¼:", data);

		setXaiData(data);
		setShowXAI(true);
	} catch (err) {
		setError(err instanceof Error ? err.message : "XAI ë¶„ì„ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
	} finally {
		setIsLoadingXAI(false);
	}
};

// Results Section ë‚´ë¶€ì— XAI ë²„íŠ¼ê³¼ ì»´í¬ë„ŒíŠ¸ ì¶”ê°€
// ê¸°ì¡´ Results Sectionì˜ ëë¶€ë¶„, ìƒì„¸ ì„±ê³¼ ë¹„êµ í…Œì´ë¸” ë‹¤ìŒì— ì¶”ê°€:

{/* XAI ë¶„ì„ ë²„íŠ¼ ë° ê²°ê³¼ */}
<div className="mt-8 text-center">
	<Button
		onClick={handleXAIAnalysis}
		disabled={isLoadingXAI}
		variant="outline"
		size="lg"
		className="bg-gradient-to-r from-purple-600 to-blue-600 text-white hover:from-purple-700 hover:to-blue-700 border-0"
	>
		<Brain className="w-5 h-5 mr-2" />
		{isLoadingXAI ? "AI ì˜ì‚¬ê²°ì • ë¶„ì„ ì¤‘..." : "AI ì˜ì‚¬ê²°ì • ê³¼ì • ë¶„ì„í•˜ê¸°"}
	</Button>
	
	{error && showResults && (
		<div className="mt-4 p-4 bg-red-50 border border-red-200 rounded-lg max-w-md mx-auto">
			<p className="text-red-600 text-sm flex items-center justify-center">
				<AlertCircle className="w-4 h-4 mr-2" />
				{error}
			</p>
		</div>
	)}
</div>

{/* XAI ì‹œê°í™” ì„¹ì…˜ */}
{showXAI && (
	<XAIVisualization 
		xaiData={xaiData} 
		isLoading={isLoadingXAI} 
	/>
)}